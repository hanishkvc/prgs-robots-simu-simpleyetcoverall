# SimpleYetCoverALL
# HanishKVC, 2016
#

gFacing = 0
gX = 0
gY = 0
gXMin = 0
gXMax = 0
gYMin = 0
gYMax = 0
gVisited = dict()
gTMCnt = 0
gPZZBlockedL1 = 0
gPZZBlockedL2 = 0
gPZZOrientCnt = 0
gAlongXVisits = dict()
gAlongYVisits = dict()
gXWidth = 0
gYWidth = 0


def move_ext(markVisited=True):
    global gX, gY
    global gXMin, gXMax, gYMin, gYMax
    if (gFacing == 0):
        gY += 1
    elif (gFacing == 1):
        gX -= 1
    elif (gFacing == 2):
        gY -= 1
    elif (gFacing == 3):
        gX += 1
    else:
        print("ERR: WRONGFACING: gFacing:{}, gX:{}, gY:{}".format(gFacing, gX, gY))
        exit()
    move()
    if markVisited:
        mark_as_visited()
    if gXMin > gX:
        gXMin = gX
    if gXMax < gX:
        gXMax = gX
    if gYMin > gY:
        gYMin = gY
    if gYMax < gY:
        gYMax = gY


def turn_left_ext():
    global gFacing
    gFacing += 1
    if (gFacing == 4):
        gFacing = 0
    turn_left()


def turn_right_ext():
    turn_left_ext()
    turn_left_ext()
    turn_left_ext()


def turn_around():
    turn_left_ext()
    turn_left_ext()


def mark_as_visited():
    sKey = "{},{}".format(gX,gY)
    gVisited[sKey] = 1


def visited_already(X=None, Y=None):
    if X is None:
        X = gX
    if Y is None:
        Y = gY
    sKey = "{},{}".format(X,Y)
    print("checking visited_already({})".format(sKey))
    if (gVisited.has_key(sKey)):
        return True
    else:
        return False


def turn_magic():
    global gTMCnt
    if (gTMCnt == 0) or (gTMCnt == 1):
        print("Turn Left")
        turn_left_ext()
    else:
        print("Turn Right")
        turn_right_ext()
    gTMCnt += 1
    if (gTMCnt >= 4):
        gTMCnt = 0


def parzigzag_changeorientation():
    global gPZZBlockedL1
    global gPZZBlockedL2
    global gTMCnt
    global gPZZOrientCnt

    gTMCnt = 0
    gPZZBlockedL1 = 0
    gPZZBlockedL2 = 0
    gPZZOrientCnt += 1
    print("Changing Orientation")


gPZZNUMOFTURNAROUND4CHANGEORIENTATION = 4
def parzigzag():
    global gPZZBlockedL1
    global gPZZBlockedL2
    global gTMCnt
    global gPZZOrientCnt
    gTMCnt = 0
    gPZZBlockedL1 = 0
    gPZZBlockedL2 = 0
    gPZZOrientCnt = 0
    print("MODE: ParZigZag")
    iCnt = 0
    bContinue = True
    while bContinue:
        sKeyExt = "{},{},{}".format(gX,gY,gFacing)
        print(sKeyExt)
        mark_as_visited()
        if front_is_clear():
            move_ext()
        else:
            turn_magic()
            if front_is_clear():
                move_ext()
            else:
                gPZZBlockedL1 += 1
                if gPZZBlockedL1 > 2:
                    gPZZBlockedL1 = 0
                    gPZZBlockedL2 += 1
                    print("Turn Around")
                    turn_around()
            if gPZZBlockedL2 < gPZZNUMOFTURNAROUND4CHANGEORIENTATION:
                turn_magic()
            else:
                parzigzag_changeorientation()
                if (gPZZOrientCnt > 4):
                    print("Done with ParZigZag")
                    bContinue = False


def dirrandomdir(dir):
    print("MODE: DirRandomDir")
    bContinue = True
    iCnt = 0
    iChange = 20
    if (dir == 0):
        turn_dir = turn_left_ext
    else:
        turn_dir = turn_right_ext
    while bContinue:
        iCnt += 1
        if (iCnt % iChange) == 0:
            iChange = 4 + roll_dice()
            print("iChange = {}".format(iChange))
            turn_dir()
        if front_is_clear():
            move_ext()
        else:
            turn_dir()


def wallfollowtest1():
    while bContinue:
        if front_is_clear():
            move_ext()
        else:
            turn_left_ext()


def wallfollowtest2():
    bContinue = True
    iCnt = 0
    while bContinue:
        iCnt += 1
        if front_is_clear():
            move_ext()
        turn_left_ext()
        while front_is_clear():
            move_ext()


def wallfollowtest3():
    bContinue = True
    turn_dir = turn_left_ext
    turn_dir_opp = turn_right_ext
    while bContinue:
        turn_dir()
        if front_is_clear():
            move_ext()
        turn_right_ext()
        if front_is_clear():
            move_ext()
        else:
            turn_dir_opp()


def walkotherway_andcomeback(iWalkEitherSide):
    gSX = gX
    gSY = gY
    gSFacing = gFacing
    for i in range(2): # Go and ComeBack so 2
        turn_around()
        while front_is_clear():
            if (gSX == gX) and (gSY == gY) and (i == 1):
                break
            move_ext()
            if (iWalkEitherSide > 0) and (i == 0):
                turn_left_ext()
                walkotherway_andcomeback(iWalkEitherSide-1)
                turn_around()
                walkotherway_andcomeback(iWalkEitherSide-1)
                turn_left_ext()


def near_lowvisitarea():
    if (gAlongXVisits[gX-1] < gYWidth):
        return True
    if (gAlongXVisits[gX] < gYWidth):
        return True
    if (gAlongXVisits[gX+1] < gYWidth):
        return True


WALL2RIGHT = 0
WALL2LEFT = 1
gWALLFOLLOWQUITCNT = 2048
gWALLFOLLOWMAXREPEATCNT = 2
def wallfollow(bWalkCorrespondingRowCol=False,iWalkEitherSide=0):
    print("MODE: WallFollow")
    wallTo = WALL2RIGHT
    turn_left_ext()
    if front_is_clear():
        turn_right_ext()
        turn_right_ext()
        if front_is_clear():
            print("No Wall to left or right, hunting...")
            while front_is_clear():
                move_ext()
            turn_left_ext()
            wallTo = WALL2RIGHT
        else:
            wallTo = WALL2RIGHT
    else:
        wallTo = WALL2LEFT
    if wallTo == WALL2LEFT:
        print("Wall to left")
        turn_dir = turn_left_ext
        turn_dir_opp = turn_right_ext
        turn_dir_opp()
    else:
        print("Wall to right")
        turn_dir = turn_right_ext
        turn_dir_opp = turn_left_ext
        turn_dir_opp()

    gSX = gX
    gSY = gY
    gSFacing = gFacing
    gSAgain = 0
    iCnt = 0
    bContinue = True
    while bContinue:
        if (gSX == gX) and (gSY == gY) and (gSFacing == gFacing):
            gSAgain += 1
            print("At Starting position [{},{},{}] after {} steps, for {} time".format(gX,gY,gFacing,iCnt,gSAgain))
            if (gSAgain >= gWALLFOLLOWMAXREPEATCNT):
                bContinue = False
        iCnt += 1
        if iCnt > gWALLFOLLOWQUITCNT:
            bContinue = False
        if (iCnt % 25) == 0:
            print("NumOf WallSide Steps = {}".format(iCnt))
        iDirCheckedCnt = 0
        while True:
            turn_dir()
            if not front_is_clear():
                break
            iDirCheckedCnt += 1
            if (iDirCheckedCnt < 3) and front_is_clear():
                move_ext()
        if bWalkCorrespondingRowCol:
            if (iWalkEitherSide > 0) and (near_lowvisitarea()):
                print("Triggering WalkEitherSide for X,Y={},{}".format(gX,gY))
                walkotherway_andcomeback(iWalkEitherSide)
            else:
                walkotherway_andcomeback(0)
        turn_dir_opp()
        if front_is_clear():
            move_ext()
        else:
            turn_dir_opp()


def wallfollow_updateparams():
    global gWALLFOLLOWQUITCNT
    iXDelta = gXMax - gXMin
    iYDelta = gYMax - gYMin
    iBoundry = iXDelta + iYDelta
    print("iBoundry Found = {}".format(iBoundry))
    gWALLFOLLOWQUITCNT = int(iBoundry * 10.3)
    print("gWALLFOLLOWQUITCNT adjusted to {}".format(gWALLFOLLOWQUITCNT))


# iTurnMod = 1, it keeps growing every turn, TooFAST
# iTurnMod = 2, it keeps growing every 2 turns, PERFECT
# iTurnMod = 3, it keeps growing every 3 turns, INTERESTING
def spiral(turn_dir, iTurnMod):
    print("MODE: Spiral")
    bContinue = True
    iCnt = 0
    iTurn = 0
    iSpiral = 1
    while bContinue:
        iCnt += 1
        if iCnt > iSpiral:
            turn_dir()
            iCnt = 0
            iTurn += 1
            if (iTurn % iTurnMod) == 0:
                iSpiral += 1
        else:
            if front_is_clear():
                move_ext()


def find_visited_rowscols():
    global gXWidth
    global gYWidth
    # Using Visited map
    # Find Ys (i.e cells of X) which are visited, for_each/along X
    # Find Xs (i.e cells of Y) which are visited, for_each/along Y
    gXWidth = (gXMax - gXMin) + 1
    gYWidth = (gYMax - gYMin) + 1
    print("X => {} to {}, Y => {} to {}".format(gXMin, gXMax, gYMin, gYMax))
    print("XWidth => {}, YWidth => {}".format(gXWidth, gYWidth))
    for x in range(gXMin, gXMax+1):
        for y in range(gYMin, gYMax+1):
            gAlongXVisits[x] = 0
            gAlongYVisits[y] = 0
    for x in range(gXMin, gXMax+1):
        for y in range(gYMin, gYMax+1):
            if (visited_already(x,y)):
                gAlongXVisits[x] += 1
                gAlongYVisits[y] += 1
    for x in range(gXMin, gXMax+1):
        print("For X[{}], numOfYs visited = {}".format(x, gAlongXVisits[x]))
    for y in range(gYMin, gYMax+1):
        print("For Y[{}], numOfXs visited = {}".format(y, gAlongYVisits[y]))
    # This may be used in future such that one
    # Follows Wall to reach these low visited areas
    # and run ParZigZag or something similar there to reach these not visited places


print(dir())

#
# Functions which potentially cover the full area most of the time
#parzigzag()
#leftrandomleft()
#dirrandomdir(1)
#
# Some interesting movements
#spiral(turn_left_ext, 2)
#
#wallfollow()
#

def superwalk_ok1():
    bContinue = True
    while bContinue:
        parzigzag()
        wallfollow_updateparams()
        wallfollow()
        find_visited_rowscols()
        bContinue = False # This is temporary for debugging

def superwalk_good():
    global gWALLFOLLOWQUITCNT
    gWALLFOLLOWQUITCNT = 301
    wallfollow(True)
    find_visited_rowscols()
    wallfollow(True,1)

superwalk_good()

